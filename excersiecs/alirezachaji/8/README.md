<div dir="rtl">

#### تمرین 8

#### بدون استفاده از توابع آماده ی متلب یک تصویر را با 45،90،120،180 درجه بچرخانید؛ در تصاویری که چرخش تصویر باعث خارج شدن از حالت مربعی می شود پیکسل های خالی را برابر رنگ مشکی قرار دهید و پیکسل های خارج شده از محدوده را نادیده بگیرید.
***
#### توضیحات کلی برنامه
در این برنامه از یک تابع جهت چرخش تصویر استفاده شده است . در متن سوال آمده است جاهایی که تصویر بعد از چرخش خالی می میاند را سیاه رنگ کنیم و جاهایی که از ابعاد تصویر اصلی بیرون میزند را نادیده بگیریم اما ما برای کامل تر شدن برنامه هر دو تصویر یعنی هم تصویر کامل و هم تصویری که گوشه های آن پس از چرخش بریده شده است را تولید کرده ایم
***

#### توضیحات بخش های برنامه
 این قسمت باعث بسته شدن تمام پنجره ها ، ریست شدن تمام متغیر ها و پاک شدن کامند ویندو می گردد <br />

</div>

```matlab

close all         
clear all         
clc    

```
***
<div dir="rtl">
 
  در این قسمت تصویر ورودی را خوانده ابعاد آن را بدست می اورد
 
 ***
 </div>
 
 
 ```matlab
a=imread("benchmark\lena.png");  
CurvaJV=figure('Name','Original Image'); 
imshow(a);  
b=a;             
n=size(a);         

```
***
<div dir="rtl">
 
  در این بخش تصویر را به صورت افقی معکوس میکند (این قسمت اضافه بر صورت سوال است)
  ***
  
 </div>

 
 ```matlab

 %%%%%%%%%%%%%%%%%%%%%%% Flip Horizentaly  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
b(1:n(1),n(2):-1:1,1:n(3))=a(1:n(1),1:n(2),1:n(3));  
CurvaJV=figure('Name','Reverse Horizentaly');        
imshow(b)                                             
```
***
<div dir="rtl">
 
 در این قسمت با استفاده از تابع نوشته شده تصویر ورودی را گرفته و به اندازه زاویه مشخص شده دوران می دهد
 ***
 
 </div>
 
 
 ```matlab

% %%%%%%%%%% 45 Degree %%%%%%%%%%%%
CurvaJV=figure('Name','45 Degree');                 
image_rotate(a,45);                                 
% %%%%%%%%%% 90 Degree %%%%%%%%%%%%
CurvaJV=figure('Name','90 Degree');               
image_rotate(a,90);                                
% %%%%%%%%%% 120 Degree %%%%%%%%%%%
CurvaJV=figure('Name','120 Degree');                 
image_rotate(a,120);                               
% %%%%%%%%%% 180 Degree %%%%%%%%%%%
CurvaJV=figure('Name','180 Degree');               
image_rotate(a,180);                                 
```
***
<div dir="rtl">
  
در این بخش تابعی که جهت دوران تصویر نوشته شده است توضیح داده شده است
ابن بخش دارای دو خروجی می باشد برای زوایایی که مورب نیستند یعنی ضریبی از 90 هستند و تصویر بعد از چرخش از ابعاد خود خارج نمی شود فقط یک خروجی تولید می شود
اما برای تصاویر مورب چون بعد از چرخش برای نمایش کامل تصویر سایز آن بزرگتر میشود یک خروجی مطابق با متن سوال بوده یعنی قسمت های اضافی را نادیده می گیرد ولی
خروجی دوم تصویر دوران داده شده را به صورت کامل نماید می دهد
 
 در بخش اول پس از تعریف تابع ابعاد تصویر را محاسبه ورودی را بدست آورده و با استفاده از روابط مثلثاتی ابعاد تصویر جدید بعد از دوران را محاسبه می کند
 همچنین با توجه به اینکه تصویر حول مرکز دوران می کند مختصات نقطه وسط تصویر را نیز بدست می آورد
 
 ***
 
 </div>
 
 
 ```matlab


image_rotate Function 
``` ruby
function pic=image_rotate(pic,angel)                 
n=size(pic);                                         
v=deg2rad(angel);                                    
r=ceil(n(1)*abs(cos(v))+n(2)*abs(sin(v)));                                
c=ceil(n(1)*abs(sin(v))+n(2)*abs(cos(v)));                         
pic2=zeros(r,c,n(3));                                
pic2=uint8(pic2);                                     
midx=ceil((size(pic2,1))/2);                        
midy=ceil((size(pic2,2))/2);                          
```
***
<div dir="rtl">
 
 در این بخش با استفاده از حلقه های تکرار و روابط مثلثاتی مختصات جدید هر پیکسل پس از دوران را محاسبه می کند و مقدار هر پیکسل در مختصات جدید را برابر
 مقدار پیکسل در مختصات قبلی قرار داده و در نهایت تصویر را نمایش می دهد.
 
 ***
 </div>
 
 
 ```matlab

for i=1:size(pic2,1)                                  
    for j=1:size(pic2,2)                                                      
         xx= round((i-midx)*cos(v)+(j-midy)*sin(v)+ceil(n(1)/2));                                       
         yy= round(-(i-midx)*sin(v)+(j-midy)*cos(v)+ceil(n(2)/2));                              
         if (xx>=1 && yy>=1 )                         
             if ( xx<=n(1) &&  yy<=n(2) )            
               pic2(i,j,1:n(3))=pic(xx,yy,1:n(3));  پیکسل مورد نظر را مقدار دهی میکند
             end  
         end
    end
end
imshow(pic2);                                       

```
***
<div dir="rtl">
 
 در این بخش ابتدا یک کپی از تصویر تولیدی بخش قبل تهیه میکند سپس بررسی می کند که آیا دوران تصویر ضریبی از 90 بوده یا خیر اگر نبوده باشد سایز تصویر تولیدی جدید از 
 ابعاد بزرگتر از تصویر اولیه می باشد به جهت اینکه ابعاد را حفظ کند از وسط تصویر شروع کرده و به اندازه نصف ابعاد تصویر در هر طرف حرکت کرده و بقیه تصویر را حذف 
 میکند و در نهایت تصویر تولیدی را چاپ میکند
 
  ***
 </div>
 
 
 ```matlab
pic3=pic;                                                  
difx=ceil((r-n(1))/2);                               
dify=ceil((c-n(2))/2);                               
if (mod(angel,90)~=0)                                
                                                     
for i=1:n(1)                                         
    for j=1:n(2)                                     
        pic3(i,j,:)=pic2(difx+i,dify+j,:);           
    end
end
CurvaJV=figure('Name','Cutted Image');                 
pic3=uint8(pic3);                                                       
imshow(pic3)                                        
end
```
![alt text](https://github.com/semnan-university-ai/image-processing-class/blob/ec436b2073664290ac3f0508f72503ef8aa13683/excersiecs/alirezachaji/8/Exce08.png)
***
