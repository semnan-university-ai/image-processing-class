<div dir="rtl">

#### تمرین 8

#### بدون استفاده از توابع آماده ی متلب یک تصویر را با 45،90،120،180 درجه بچرخانید؛ در تصاویری که چرخش تصویر باعث خارج شدن از حالت مربعی می شود پیکسل های خالی را برابر رنگ مشکی قرار دهید و پیکسل های خارج شده از محدوده را نادیده بگیرید.
***
#### توضیحات کلی برنامه
در این برنامه از یک تابع جهت چرخش تصویر استفاده شده است . در متن سوال آمده است جاهایی که تصویر بعد از چرخش خالی می میاند را سیاه رنگ کنیم و جاهایی که از ابعاد تصویر اصلی بیرون میزند را نادیده بگیریم اما ما برای کامل تر شدن برنامه هر دو تصویر یعنی هم تصویر کامل و هم تصویری که گوشه های آن پس از چرخش بریده شده است را تولید کرده ایم
***

#### توضیحات بخش های برنامه
 این قسمت باعث بسته شدن تمام پنجره ها ، ریست شدن تمام متغیر ها و پاک شدن کامند ویندو می گردد <br />

</div>

```matlab

close all         
clear all         
clc    

```
***
<div dir="rtl">
 
  در این قسمت تصویر ورودی را خوانده ابعاد آن را بدست می اورد
 
 </div>
 ***
 
 ```matlab
a=imread("benchmark\lena.png");  
CurvaJV=figure('Name','Original Image'); 
imshow(a);  
b=a;             
n=size(a);         

```
***
<div dir="rtl">
 
  در این بخش تصویر را به صورت افقی معکوس میکند (این قسمت اضافه بر صورت سوال است)
 
 </div>
 ***
 
 ```matlab

 %%%%%%%%%%%%%%%%%%%%%%% Flip Horizentaly  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
b(1:n(1),n(2):-1:1,1:n(3))=a(1:n(1),1:n(2),1:n(3));  
CurvaJV=figure('Name','Reverse Horizentaly');        
imshow(b)                                             
```
***
<div dir="rtl">
 
 در این قسمت با استفاده از تابع نوشته شده تصویر ورودی را گرفته و به اندازه زاویه مشخص شده دوران می دهد
 
 </div>
 ***
 
 ```matlab

% %%%%%%%%%% 45 Degree %%%%%%%%%%%%
CurvaJV=figure('Name','45 Degree');                 
image_rotate(a,45);                                 
% %%%%%%%%%% 90 Degree %%%%%%%%%%%%
CurvaJV=figure('Name','90 Degree');               
image_rotate(a,90);                                
% %%%%%%%%%% 120 Degree %%%%%%%%%%%
CurvaJV=figure('Name','120 Degree');                 
image_rotate(a,120);                               
% %%%%%%%%%% 180 Degree %%%%%%%%%%%
CurvaJV=figure('Name','180 Degree');               
image_rotate(a,180);                                 
```
***
<div dir="rtl">
  
در این بخش تابعی که جهت دوران تصویر نوشته شده است توضیح داده شده است
ابن بخش دارای دو خروجی می باشد برای زوایایی که مورب نیستند یعنی ضریبی از 90 هستند و تصویر بعد از چرخش از ابعاد خود خارج نمی شود فقط یک خروجی تولید می شود
اما برای تصاویر مورب چون بعد از چرخش برای نمایش کامل تصویر سایز آن بزرگتر میشود یک خروجی مطابق با متن سوال بوده یعنی قسمت های اضافی را نادیده می گیرد ولی
خروجی دوم تصویر دوران داده شده را به صورت کامل نماید می دهد
 
 در بخش اول پس از تعریف تابع ابعاد تصویر را محاسبه ورودی را بدست آورده و با استفاده از روابط مثلثاتی ابعاد تصویر جدید بعد از دوران را محاسبه می کند
 همچنین با توجه به اینکه تصویر حول مرکز دوران می کند مختصات نقطه وسط تصویر را نیز بدست می آورد
 </div>
 
 ***
 ```matlab


image_rotate Function 
``` ruby
function pic=image_rotate(pic,angel)                 
n=size(pic);                                         
v=deg2rad(angel);                                    
r=ceil(n(1)*abs(cos(v))+n(2)*abs(sin(v)));                                
c=ceil(n(1)*abs(sin(v))+n(2)*abs(cos(v)));                         
pic2=zeros(r,c,n(3));                                
pic2=uint8(pic2);                                     
midx=ceil((size(pic2,1))/2);                        
midy=ceil((size(pic2,2))/2);                          
```
***

for i=1:size(pic2,1)                                  % حلقه جهت حرکت در پیکسل های سطری 
    for j=1:size(pic2,2)                              % حلقه جهت حرکت در پیکسل های ستونی                        
         xx= round((i-midx)*cos(v)+(j-midy)*sin(v)+ceil(n(1)/2));  % مختصات ستونی جدید تصویر دوران یافته را بدست می آورد                                      
         yy= round(-(i-midx)*sin(v)+(j-midy)*cos(v)+ceil(n(2)/2)); % مختصات سطری جدید تصویر دوران یافته را بدست می آورد                             
         if (xx>=1 && yy>=1 )                         % بررسی میکند که مختصات پیکسل مثبت و بزرگتر از 0 باشند
             if ( xx<=n(1) &&  yy<=n(2) )             % بررسی میکند که مختصات پیکسل بدست امده از ابعاد مورد نظر بیشتر نباشد
               pic2(i,j,1:n(3))=pic(xx,yy,1:n(3));    % پیکسل مورد نظر را مقدار دهی میکند
             end  
         end
    end
end
imshow(pic2);                                         % تصویر را نمایش می دهد
pic3=pic;
                                                      % در این برنامه دو تصویر به ازای تصاویر مایل رسم می گردد یکی کل تصویر در تصویر جدید مشخص است 
                                                      % و ابعاد تصویر جدید بزرگتر از تصویر اولیه است و تصویر دوم ابعاد تصویر برابر تصویر اولیه است
                                                      % ولی قسمتی از کوشه های تصویر حذف شده است قسمت بعدی برنامه تصویر دوم را تولید میکند
difx=ceil((r-n(1))/2);                                % میزان اختلاف پیکسل تصیر اول و دوم را در حالت ستونی مشخص میکند
dify=ceil((c-n(2))/2);                                % میزان اختلاف پیکسل تصیر اول و دوم را در حالت ستونی مشخص میکند
if (mod(angel,90)~=0)                                 % بررسی میکند آیا تصویر دوم نیاز است رسم شود یا خیر اگر چرخش دورانی 90 درجه ای کامل نداشته باشد نیاز نیست رسم شود
                                                      % چون ابعاد تصویر جدید برابر تصویر اصلی خواهد شد
for i=1:n(1)                                          % حلقه تکرار ستونی جهت آدرس دهی تصویر دوم
    for j=1:n(2)                                      % حلقه تکرار ستونی جهت آدرس دهی تصویر دوم
        pic3(i,j,:)=pic2(difx+i,dify+j,:);            % پیکسل های تصویر دوم را مقدار دهی میکند
    end
end
CurvaJV=figure('Name','Cutted Image');                % فیگوری برای تصویر دوم ایجاد میکند  
pic3=uint8(pic3);                                     % تغییر می دهد uint8 نوع داده تصویر را به                   
imshow(pic3)                                          % تصویر دوم را نمایش می دهد
end
```
![alt text](https://github.com/semnan-university-ai/image-processing-class/blob/ec436b2073664290ac3f0508f72503ef8aa13683/excersiecs/alirezachaji/8/Exce08.png)
***
